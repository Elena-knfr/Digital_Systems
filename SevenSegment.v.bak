module part2(SW, KEY, LEDR, HEX0, HEX1, HEX2, HEX3, HEX4, HEX5);
	input [9:0]SW;
	input [3:0]KEY;
	output reg [7:0]LEDR; 
	output [6:0]HEX0, HEX1, HEX2, HEX3, HEX4, HEX5;
	
	wire [7:0]s;
	//reg [7:0]s_reg;
	ALU al(SW[3:0], SW[7:4], KEY[3:1], s[7:0]);
	
	always@(posedge KEY[0])
	begin
		if (SW[9] == 1'b0) // RESET == 1
			LEDR <= 0;
		else
			LEDR <= s;
	end
	
	segment7 seg0(SW[3:0], HEX0);
	segment7 seg1(4'b0000, HEX1);
	segment7 seg2(4'b0000, HEX2);
	segment7 seg3(4'b0000, HEX3);
	segment7 seg4(LEDR[3:0], HEX4); //least significant 4 bits of register output
	segment7 seg5(LEDR[7:4], HEX5); //most significant 4 bits of register output
endmodule

module ALU(C, D, func, ALUout);
	input [3:0]C;
	input [3:0]D;
	input [2:0]func;
	output reg [7:0]ALUout;	
	
	wire [3:0]c1; //output of ripple carry adder
	wire c2; //carry
	ripple_carry_adder F_A(C, D, 1'b0, c1, c2); 
	
	always@(*)
	begin
		case(func)
			3'b000: ALUout = {3'b000, c2, c1} //A + B using the adder from Part II of this Lab
			3'b001: ALUout = {3'b0, (C[3:0]+D[3:0])}; //A + B using the Verilog ‘+’ operator
			3'b010: ALUout = {{5{D[3]}}, D[2:0]}; //Sign extension of B to 8 bits?????????????????????
			3'b011:  //Output 8’b00000001 if at least 1 of the 8 bits in the two inputs is 1 using a single OR operation
				if(D[3:0] | C[3:0])
					ALUout = 8'b00000001;
				else 
					ALUout = 8'b00000000;
			3'b100: //Output 8’b00000001 if all of the 8 bits in the two inputs are 1 using a single AND operation
				if(D[3:0] & C[3:0])
					ALUout = 8'b00000001;
				else 
					ALUout = 8'b00000000;
			3'b101: ALUout =A * (2**B); //Left shift A by B bits
			default: ALUout = D[3:0]*C[3:0]; //A × B using the Verilog ‘*’ operator
		endcase
	end
endmodule


module ripple_carry_adder(A, B, Cin, S, Cout);
	input [3:0]A, B;
	input Cin;
	output [3:0]S;
	output Cout;
	wire c1, c2, c3;
	
	FA bit0(A[0], B[0], Cin, S[0], c1);
	FA bit1(A[1], B[1], c1, S[1], c2);
	FA bit2(A[2], B[2], c2, S[2], c3);
	FA bit3(A[3], B[3], c3, S[3], Cout);
endmodule

module FA(a, b, cin, s, cout);
	input a, b, cin;
	output s, cout;
	assign s = cin ^ a ^ b;
	assign cout = (a & b) | (a & cin) | (b & cin);
endmodule

module segment7(X, hex);
	input[3:0]X;
	output reg [6:0]hex;
	
	always @(*)
	begin
		case(X)
			4'b0000: hex = 7'b1000000;
			4'b0001: hex = 7'b1111001;
			4'b0010: hex = 7'b0100100;
			4'b0011: hex = 7'b0110000;
			4'b0100: hex = 7'b0011001;
			4'b0101: hex = 7'b0010010;
			4'b0110: hex = 7'b0000010;
			4'b0111: hex = 7'b1111000;
			4'b1000: hex = 7'b0000000;
			4'b1001: hex = 7'b0010000;
			4'b1010: hex = 7'b0001000;
			4'b1011: hex = 7'b0000011;
			4'b1100: hex = 7'b1000110;
			4'b1101: hex = 7'b0100001;
			4'b1110: hex = 7'b0000110;
			4'b1111: hex = 7'b0001110;
			default: hex = 7'b1000000;
		endcase
	end
endmodule	

